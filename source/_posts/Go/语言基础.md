---
title: 基础部分
categories: Go
---

## 文档

> [https://studygolang.com/pkgdoc](https://studygolang.com/pkgdoc) API 中文文档

> [http://docscn.studygolang.com/](http://docscn.studygolang.com/) 官方

## 基础指令

`go run main.go` 运行 golang 的代码

`go build`命令来生成二进制文件

> 当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）

## 环境变量

环境变量`GOROOT`表示 Go 语言的安装目录
环境变量`GOPATH`用于指定我们的开发工作区(workspace),是存放源代码、测试文件、库静态文件、可执行文件的工作。
环境变量`GOBIN`表示我们开发程序编译后二进制命令的安装目录

```go
export GOBIN=$GOPATH/bin
```

## 安装报错提示

```go
go.mod file not found in current directory or any parent directory; see 'go help modules'

 // go的环境设置问题，执行
go env -w GO111MODULE=auto

```

## 执行流程的分析

```text

如果使用go build对源码进行编译

执行过程如下

​					(go build)

.go文件 ============> 可执行文件（window下.exe可执行文件）==============>结果

​					(编译)																								(运行)

如果是对源码直接go run 源码  Go的执行流程:

.go文件 ==============================> 结果

​							编译运行都在这一步

​							(底层处理 还是会编译成可

​							执行文件在进行执行)

```

## 对于两种流程的分析

1. 如果先 go build 编译成了可执行文件 我们可以将该可执行文件拷贝到没有 GO 环境的机器上 他任然可以运行
2. 如果我们直接 go run go 的源码 那么如果要在另外一个机器上运行 也需要 go 的开发环境 否则无法执行
3. go build 的时候 编译器会将程序运行的依赖的库文件包含在可执行文件中 所以 go build 后可执行文件会比源码要大

## 编译自定义生成 exe 文件名

```go
go build -o myMain.exe main.go
```

> go 语言是一行一行编译的 多条语句在一行会报错
> `go 语言定义的变量或者 import的包如果没有使用到 代码不能编译通过`

## 格式化

```go
gofmt -w main.go //会格式化.go文件
```

## 查看一个变量的数据类型和字节数

- %T 查看数据类型
- %d 数字类型
- %c 字符类型
- %s 字符串类型

```go

package main

import(
	 "fmt"
	 "unsafe"
)

func main()  {

var n2 int64 = 10
	fmt.Printf("n2的数据类型 %T n2占用的字节数是%d",n2,unsafe.Sizeof(n2))
}

```

## range 遍历
```go
package main  
  
import "fmt"  
  
func main() {  
   nums := []int{2, 3, 4}  
  
   sum := 0  
   for index, item := range nums {  
      fmt.Println(index)  
      fmt.Println(item)  
      sum += item  
   }  
  
   fmt.Println(sum)  
  
   m := map[string]string{"a": "aaa", "b": "bbb"}  
  
   for key, value := range m {  
      fmt.Println(key)  
      fmt.Println(value)     
   }  
}
```

## 函数

```GO
func add(a int, b int) int {  
   return a + b  
}  
  
func add1(a, b int) int {  
   return a + b  
}  
  
func exists(m map[string]string, k string) (string, bool) {  
   v, ok := m[k]  
   return v, ok  
}
```

## 指针
golang 中一切都是值传递
```go
func changeIntegerValue(i *int) {  
   *i += 2  
}  
  
func changeMapperValue(m *map[string]int) {  
   value := (*m)["string"]  
   fmt.Println(value)  
}  
  
func main() {  
   // 指针  
   n := 5  
   changeIntegerValue(&n)  
   fmt.Println(n)  
  
   mm := map[string]int{"aa": 123}
   // 引用类型 指针  
   changeMapperValue(&mm)  
}
```
## 结构体
```go
package main  
  
import "fmt"  
  
type user struct {  
   name     string  
   password string  
}  
  
func main() {  
   // 没有的值会用类型的初始化值  
   a := user{name: "s", password: "123"}  
   fmt.Println(a)  
   b := user{name: "aa"}  
   fmt.Println(b)  
   c := user{password: "123"}  
   fmt.Println(c)  
   var d user  
   fmt.Println(d) // 空对象  
   fmt.Println(d.name)  
   fmt.Println(d.password)  
}
```